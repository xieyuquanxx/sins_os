# 批处理Batch System
> 批处理系统: 将所有应用程序存在内存中，操作系统会自动加载应用程序进行执行，执行完一个后自动加载执行下一个应用程序，直到所有应用全部执行完毕。

根据定义，批处理系统需要做到以下功能：
1. 能够知道所有应用程序在内存中的位置(人为约定即可)，其实知道应用程序的第一行代码的位置和长度就行。
2. 能够加载应用程序到指定位置
   1. 保存所有应用程序的位置信息
3. 能够处理应用程序的系统调用
   1. 具有保存和恢复上下文的能力


应用程序被编译并剥离元数据后会得到`xxx.bin`二进制镜像文件，我们需要把它们作为内核的数据段链接到内核中。

## 特权级切换
当执行一条Trap类指令(`ecall`)时，处理器和操作系统会完成到内核态执行环境的切换，并在操作系统完成服务后，再次切换到用户态执行环境，在下一条指令处继续执行。

应用程序的上下文包括**通用寄存器**和**栈**两个主要部分。

### 硬件控制机制
当CPU执行完一条指令并准备从用户特权级Trap到S特权级时，硬件会自动完成以下事情：
1. 将`sstatus`的`SPP`字段修改为CPU当前的特权级(U/S)
2. `sepc`会被修改为Trap处理完成后默认会执行的下一条指令的地址(返回的地址)
3. CPU跳转到`stvec`所设置的Trap处理入口地址，并将当前特权级设置为S，然后从Trap入口地址处开始执行


完成Trap处理准备返回的时候，需要一条S特权级的指令`sret`来完成，它会完成以下事情：
1. 将当前的特权级赋给`sstatus`的`SPP`字段(U/S)
2. 跳转到`sepc`寄存器指向的那条指令，然后开始执行

### 用户栈与内核栈
在正式进入S特权的Trap处理之前，我们必须保存原控制流的寄存器状态，这一般通过内核栈来保存。
这就涉及到换栈的操作。
首先需要定义用户栈和内核栈，
```rust
#[repr(align(4096))]
struct KernelStack {
    data: [u8; KERNEL_STACK_SIZE],
}

#[repr(align(4096))]
struct UserStack {
    data: [u8; USER_STACK_SIZE],
}
```
然后声明静态变量，它们会保存在`.bss`段，
```rust
static KERNEL_STACK: KernelStack = KernelStack {
    data: [0; KERNEL_STACK_SIZE],
};

static USER_STACK: UserStack = UserStack {
    data: [0; USER_STACK_SIZE],
};
```